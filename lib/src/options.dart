import 'dart:io';

import 'package:args/args.dart';
import 'package:path/path.dart' as p;

/// Global options
class Options {
  String branch = defaultGitBranch;
  // buildDir isn't user configurable (yet).
  String buildDir = 'build'; // Path to build directory relative to package root
  bool dryRun = true;
  bool forceBuild = false;
  String ghPagesAppDir;
  bool keepTmp = false;
  bool pubGet = false;
  String get pubGetOrUpgrade => pubGet ? 'get' : 'upgrade';
  bool push = true;
  /*@nullable*/ RegExp match, skip;
  String url = 'main';
  String user = 'dart-lang';
  bool verbose = false;
  // Usage help text generated by arg parser
  String usage = '';
  /*@nullable*/ String workDir;
  String webCompiler = 'dart2js';

  bool get isValidWorkDir {
    if (workDir == null) return true;
    final path = new Directory(workDir);
    return path.existsSync();
  }

  int get _ngVers => int.parse(ghPagesAppDir);
  bool get useNewBuild => _ngVers >= 5;

  RegExp get _buildDirRE => new RegExp(r'\b' + buildDir + r'\b');
  bool containsBuildDir(String path) => _buildDirRE.hasMatch(path);

  String get webdevURL => url == 'main' ? _webdevURL : _webdevDevURL;
}

Options options = new Options();

// TODO: make these configurable? (with defaults as given)
const buildInfoFileName = 'build-info.json';
const defaultGitBranch = 'master';
const docExampleDirRoot = 'examples';
const exampleConfigFileName = '.docsync.json';
const tempFolderNamePrefix = 'dds-';
const _webdevURL = 'https://webdev.dartlang.org';
const _webdevDevURL = 'https://webdev-dartlang-org-dev.firebaseapp.com';
const readmeMd = 'README.md';

Directory initWorkingDir() {
  final tmpEnvVar = Platform.environment['TMP'];
  if (tmpEnvVar != null) {
    final dir = new Directory(tmpEnvVar);
    if (dir.existsSync()) return dir;
  }
  return Directory.systemTemp;
}

Directory workDir;

const Map<String, String> _help = const {
  'branch': '<branch-name>\nGit branch to fetch webdev and examples from',
  'gh-pages-app-dir': '<path>\nDirectory in which the generated example apps '
      'will be placed (gh-pages branch)\n',
  'dry-run': 'Show which commands would be executed but make (almost) '
      'no changes;\nonly the temporary directory will be created',
  'force-build': 'Forces build of example app when sources have not changed',
  'help': 'Show this usage information',
  'keep-tmp': 'Do not delete temporary working directory once done',
  'pub-get': 'Use `pub get` instead of `pub upgrade` before building apps',
  'push': 'Prepare updates and push to example repo',
  'match': '<dart-regexp>\n'
      'Sync all examples having a data file ($exampleConfigFileName)\n'
      'and whose repo path matches the given regular expression;\n'
      'use "." to match all',
  'skip': '<dart-regexp>\nNegative filter applied to the project list created '
      'by use of the --match option',
  'url': '[dev|main]\nWebdev site URL to use in generated README.',
  'user': '<user-id>\nGitHub id of repo to fetch examples from',
  'web-compiler': '<compiler>, either dart2js or dartdevc',
  'work-dir': '<path>\nPath to a working directory; when unspecified '
      'a system-generated path to a temporary directory is used'
};

/// Processes command line options and returns remaining arguments.
List<String> processArgs(List<String> args) {
  ArgParser argParser = new ArgParser(allowTrailingOptions: true)
    ..addFlag(
      'help',
      abbr: 'h',
      negatable: false,
      help: _help['help'],
    )
    ..addOption(
      'branch',
      abbr: 'b',
      help: _help['branch'],
      defaultsTo: options.branch,
    )
    ..addFlag(
      'dry-run',
      abbr: 'n',
      negatable: false,
      help: _help['dry-run'],
    )
    ..addFlag(
      'force-build',
      abbr: 'f',
      negatable: false,
      help: _help['force-build'],
    )
    ..addOption(
      'gh-pages-app-dir',
      abbr: 'g',
      help: _help['gh-pages-app-dir'],
      defaultsTo: options.ghPagesAppDir,
    )
    ..addFlag(
      'keep-tmp',
      abbr: 'k',
      negatable: false,
      help: _help['keep-tmp'],
    )
    ..addFlag(
      'pub-get',
      help: _help['pub-get'],
      negatable: false,
      defaultsTo: options.pubGet,
    )
    ..addFlag(
      'push',
      abbr: 'p',
      help: _help['push'],
      defaultsTo: options.push,
    )
    ..addOption(
      'match',
      abbr: 'm',
      help: _help['match'],
    )
    ..addOption(
      'skip',
      help: _help['skip'],
    )
    ..addOption(
      'url',
      help: _help['url'],
      defaultsTo: options.url,
    )
    ..addOption(
      'user',
      abbr: 'u',
      help: _help['user'],
      defaultsTo: options.user,
    )
    ..addFlag(
      'verbose',
      abbr: 'v',
      negatable: false,
      defaultsTo: options.verbose,
    )
    ..addOption(
      'web-compiler',
      help: _help['web-compiler'],
      defaultsTo: options.webCompiler,
    )
    ..addOption(
      'work-dir',
      abbr: 'w',
      help: _help['work-dir'],
    );

  var argResults;
  try {
    argResults = argParser.parse(args);
  } on FormatException catch (e) {
    printUsageAndExit(e.message, 0);
  }

  options.usage = argParser.usage;
  if (argResults['help']) printUsageAndExit();

  options
    ..branch = argResults['branch']
    ..dryRun = argResults['dry-run']
    ..forceBuild = argResults['force-build']
    ..ghPagesAppDir = argResults['gh-pages-app-dir']
    ..keepTmp = argResults['keep-tmp']
    ..pubGet = argResults['pub-get']
    ..push = argResults['push']
    ..match =
        argResults['match'] != null ? new RegExp(argResults['match']) : null
    ..skip = argResults['skip'] != null ? new RegExp(argResults['skip']) : null
    ..url = argResults['url']
    ..user = argResults['user']
    ..verbose = argResults['verbose']
    ..webCompiler = argResults['web-compiler']
    ..workDir = argResults['work-dir'];

  validateAndNormalizeGhPagesAppDir();

  if (options.webCompiler != 'dart2js' && options.webCompiler != 'dartdevc')
    printUsageAndExit("Invalid --web-compiler '${options.webCompiler}'");

  if (!options.isValidWorkDir)
    printUsageAndExit("Invalid --workDir '${options.workDir}'");

  workDir = options.workDir == null
      ? initWorkingDir().createTempSync(tempFolderNamePrefix)
      : new Directory(options.workDir);

  return argResults.rest;
}

void validateAndNormalizeGhPagesAppDir() {
  // FIXME: revert temporary change once all scripts have been updated. Also make '' the new default.
  // Temporarily making --gh-pages-app-dir mandatory.
  if (options.ghPagesAppDir == null)
    printUsageAndExit("Option --gh-pages-app-dir is currently mandatory, "
        "and it usually matches the major Angular version number being used "
        "by the example apps; e.g., --gh-pages-app-dir=4. "
        "Use '' if you reall mean to use an empty path");

  if (options.ghPagesAppDir.startsWith('/'))
    printUsageAndExit("Invalid --gh-pages-app-dir '${options.ghPagesAppDir}'; "
        'path must be relative');

  if (options.ghPagesAppDir.isNotEmpty && options.ghPagesAppDir.endsWith('/'))
    options.ghPagesAppDir =
        options.ghPagesAppDir.substring(0, options.ghPagesAppDir.length - 1);
}

void printUsageAndExit([String _msg, int exitCode = 1]) {
  var msg = 'Syncs Angular docs example apps';
  if (_msg != null) msg = _msg;
  print('''

$msg.

Usage: ${p.basenameWithoutExtension(Platform.script.path)} [options] [<exampleName> | <examplePath> <exampleRepo>]

${options.usage}
''');
  exit(exitCode);
}
